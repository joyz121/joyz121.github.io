---
layout: post
title: "Particle swarm optimization"
subtitle: "粒子群算法"
author: "Joy"
header-img: "img/post-bg-rwd.jpg"
header-mask: 0.2
tags:
  - 机器学习
---

## 一、简介

​		从20世纪90年代初，就产生了模拟自然生物群体(swarm)行为的优化技术。Dorigo等从生物进化的 机理中收到启发，通过模拟蚂蚁的寻径行为，提出了蚁群优化方法；Eberhart和Kennedy于1995年提出的粒子群优化算法是基于对鸟群鱼群的模拟。这些研究可以称为群体智能（swarm intelligence）。通常单个自然生物并不是智能的，但是整个生物群体却表现出处理复杂问题的能力，群体智能就是这些团体行为在人工智能问题中的应用。粒子群优化最初是处理连续优化问题的，目前其应用已扩展到组合优 化问题。由于其简单、有效的特点，PSO已经得到了广泛应用。

## 二、基本概念

​		每只鸟在某处位置能够找到食物的可能可以通过适应值来刻画，每只鸟能够记住自己的觅食位置，并且找到其中的最佳位置（局部最优），鸟群中所有个体的最佳位置就可以看做整个鸟群的最佳觅食点（全局最优）。可以预见的是，整个鸟群的觅食活动总体上一定是往这个全局最优的觅食区域运动的，通过鸟 群觅食位置的不断移动即不断地迭代，速度的不断更新，鸟群往该最优位置步步逼近。鸟群中的每一个个体都可以当做一个粒子，鸟群即可被看做粒子群。假设一个有M个粒子的粒子群在一个N维空间内寻找最优位置，那么可以对每个粒子z在该空间中赋予一个“位置”:$X_i$=$(x_i^1,x_i^2,...,x_i^N)$,$i=1,2,3,...,M$。

​		对于每一个粒子而言，该位置即为问题的一个潜在解，在这个位置能觅到食物的可能性有多大呢？可以通过将 $X_i$ 带入目标函数计算其适应值，根据适应值大小来衡量其优劣。在每一次的搜寻过程中，记录每个粒子的局部最优位置: $P_i$=$(p_i^1,p_i^2,...,p_i^N)$,$i=1,2,3,...,M$。

​		在觅食搜寻过程中，所有粒子最优位置的最优解即可当做整个粒子群的整体最优位置：$G_{best}$=$(g^1,g^2,...,g^N)$。

​		反复进行食物的搜寻过程（进行迭代），直至找到全局最优解为止。当然在每一次位置的寻找之后， 应该对粒子的速度和所在位置进行更新，记第兩个粒子的速度为： $V_i$=$(v_i^1,v_i^2,...,v_i^N)$,$i=1,2,3,...,M$。

​		粒子的速度及位置更新方式如下:

$v_i^d$=$wv_i^d+c_1r_1(p_i^d-x_i^d)+c_2r_2(g^d-x_i^d)$

$x_i^d=x_i^d+av_i^d$

​		其中：$i=1,2,3,...,M$;$d=1,2,3,...,N$。

​		$w$是一个非负数，称为惯性因子，对算法的收敛起到很大的作用，其值越大，粒子飞跃的范围越广，越容易找到全局最优，但也会错失局部搜索的能力。

​		$c_1,c_2$是非负的加速度常数，是调整局部最优值和全局最优值权重的参数，如果前者为零，说明搜索过程中没有自身经验只有社会经验，容易陷入局部最优解；若后者为零，则只有社会经验没有自身经验，常常会陷入局部最优解中，不能飞跃该局部最优区域。

​		$r_1,r_2$是$[0,1]$的随机数,$a$是约束因子，目的是控制速度的权重。

从上面速度和位置分量的改变规则我们可以看到，速度的存在的根本作用还是为了改变粒子的位置， 计算新一轮粒子的适应值，其中的参数的设置也会影响到对全局最优解的搜寻。在一般情况下，我们会对粒子的速度分量进行限制，如果粒子的速度分量在更新之后超过最大飞翔速度，则应该根据不同的情况进行优化问题的设定。 迭代终止条件根据具体问题而定，一般达到预定最大迭代次数或者粒子群目前为止搜寻到的最优位置满足目标函数的最小容许误差。 

## 三、Matlab算法实现

对于每个粒子：

假设有M个粒子需要在N维空间内寻找最优位置

- 当前位置：$x$
- 当前适应度（函数值):$F(x)$
- 历史最优位置:$X_{pbest}$
- 历史最优适应度$F_{pbest}$

对于全部粒子：

- 粒子数：$num$
- 迭代次数：$cnt$
- 全局最优位置：$X_{gbest}$
- 全局最优适应度：$F_{gbest}$
- 位置范围：$[x_{min},x_{max}]$
- 速度范围：$[v_{min},v_{max}]$
- 速度计算参数：$C_1,C_2$
- 惯性因子$w$

每个粒子的位置更新公式

$ V=C_1*Rand()*(x_{pbest}-x)+C_2*Rand()*(x_{gbest}-x) $

$x=x+V$

```matlab
x_min=-2;       %位置范围
x_max=2;
num=40;         %粒子数
cnt=20;         %迭代次数
dimension = 1;  %粒子位置维度
C_1=2;          %自身加速常数
C_2=2;          %社会加速常数
w=0.6;          %惯性银子
v_max=0.8;      %速度最大值
%init
x=x_min+rand(num,dimension).*(x_max-x_min);%位置初始化
v=rand(num,dimension)%粒子速度初始化
x_pbest=x;%粒子最优位置初始化
f_pbest=target(x);
x_gbest=x(1,:);
f_gbest=inf;

%plot the function
horizon = linspace(x_min,x_max,500);
vertical = target(horizon);
plot(horizon,vertical);
hold on
pic_num = 1;
t=1;
%PSO算法
while t<=cnt
    %寻找局部最优
    for i=1:num
        f(i)=target(x(i));
        if f(i)>f_pbest(i)
            x_pbest(i)=x(i);
            f_pbest(i)=f(i);
        end
    end
    %寻找全局最优
    [f_gbest,index]=max(f_pbest);
    x_gbest=x(index);
    %更新粒子位置
    for i=1:num
        %速度计算
        v(i)=w*v(i)*C_1*rand()*(x_pbest(i)-x(i))+C_2*rand()*(x_gbest-x(i));
        %速度越界
        if v(i)>v_max
            v(i)=v_max;
        elseif v(i)<-v_max
            v(i)=-v_max;
        end
        %位置计算
        x(i)=x(i)+v(i);
        %位置越界
        if x(i)>x_max
            x(i)=x_max;
        elseif x(i)<x_min
            x(i)=x_min;
        end
    end
    t=t+1;
    %获取动态搜寻过程gif图
    figure(1)
    scatter(x_gbest,target(x_gbest))
    hold on
    h1=text(6,-4,['X by TSO=',num2str(x_gbest)]);
    h2=text(6,-6,['Y by TSO=',num2str(target(x_gbest))]);
    pause(0.2)
    drawnow;
    F=getframe(gcf);
    I=frame2im(F);
    [I,map]=rgb2ind(I,256);
    if pic_num == 1
        imwrite(I,map,'PSO.gif','gif', 'Loopcount',inf,'DelayTime',0.2);
    else  					               						imwrite(I,map,'PSO.gif','gif','WriteMode','append','DelayTime',0.2);
    end
    
    delete(h1);
    delete(h2)
    pic_num = pic_num + 1;
end
string=['Max-value is ',num2str(f_gbest),', where x= ',num2str(x_gbest)];
title(string)
```

